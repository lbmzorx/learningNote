# 调度

调度程序负责选择下一个要运行的进程，在可运行态进程之间分配有限的处理器时间资源的代码。


分为 

- **抢占式多任务 √**
> 调度程序来决定什么时候停止一个进程的运行以便于其他进程能够得到执行机会。
> 
> 这个强制挂起来的动作就叫**抢占**。
> 
> 进程在被抢占之前能够运行的时间是预先设置好的，叫**时间片**
> 
> Linux采用动态方法计算时间片

- **非抢占式多任务 **
> 除非进程自己主动主动停止，否则它会一直执行。
> 
> 进程主动挂起自己的操作叫**让步** yielding
> > 缺点：一个绝不让步的悬挂进程就能使系统崩溃

### 3.1.2 进程优先级

基于优先级调度: 根据进程的价值和对其处理器时间德尔需求来对进程分级，优先级高的先运行，相同 优先级的进程按轮转方式进行调度（一个接一个，重复进行）。

linux实现了动态优先级的调度方法。提供两组独立的优先级范围

1. nice值，从 -20 到 19 ，默认0，nice值越大优先级越低--nice值大的进程在系统中为其他程序做好事-_-(being nice)
2. 实时优先级，

### 3.1.3 时间片

```
更低的优先级           更高的优先级或
<-------------+      +------------->
更低的交互性           更高的交互性

 +               +                 +
 |               |                 |
 +---------------------------------+
 |               |                 |
 +               +                 +
最小              默认               最大
10ms           100ms              200ms

         进程时间片的计算

```

### 3.1.4 进程抢占
当一个进程进入TASK_RUNNING状态，内个简称他的优先级是否高于当前正在执行的进程。
是调度程序会被唤醒，重新选择新的进程执行，此外当一个进程的时间片变为0时它会被抢占，调度程序被唤醒以选择一个新的进程
### 3.1.5 调度策略的活动
- 一个文字编辑程序: I/O 消耗型，大部分等待用户的键盘输入，优先级较高和较长的时间片
- 一个视频编码程序: 处理器消耗型，文字编辑程序仅仅只有输入的那一会儿运行，所以视频编码程序可以在所有剩余时间中独享处理器

### 3.2 调度算法

目的:

- 充分时间O(1)调度
- 多处理器的可拓展性
- 加强交互性能
- 保证公平
- 优化也完全又能里拓展到具有多处理器且每个处理器上运行多个进程的系统中


| 时间片 | 长度       | 交互性 | nice值       |
|--------|------------|--------|--------------|
| 初始值 | 父进程一半 | N/A    | 与父进程相同 |
| 最小值 | 10ms       | 低     | 大           |
| 默认值 | 100ms      | 平均   | 0            |
| 最大值 | 200ms      | 高     | 小           |

### 3.2.5 睡眠和唤醒

休眠（被阻塞）的进程处于一个特殊的不可执行状态。
休眠的一个常见原因就是文件I/O 

```
                   _add_wait_queue()将任务加入到等待队列中
                   设置任务状态TASK_INTERRUPTIBLE
                   schedule()
                   deactivate_task()将该任务从运行队列移出
                  +------------------------------------+
                  |                                    |
                  |                                    |
                  |                                    |     
     任务可以运行 |            接收信号                | 任务不可运行
          +-------+--------+               +-----------v-----------+
          |TASK_RUNNING    | <-------------+TASK_INTERRUPTIBLE     |
          +-------^--------+               +------------+----------+
                  |                                     |
                  |                                     |
                  |                                     |
                  |                                     |
                  +-------------------------------------+
                    当任务等待的事件发时，
                    try_to_wake_up()把任务状态设置为TASK_RUNNING
                    active_task()将任务加入到运行队列中
                    schedule()
                    __remove_wait_queue() 将任务从等待队列中移出

```

### 3.2.6 负载平衡

```
+--------+                         +--------+
| 进程1  |--->                     | 进程1  |
| 进程2  +---> +--------------+    | 进程2  |
| ...    |     |load_balance()|    | ...    |
| 进程20 |     +--------------+    | 进程15 |
|        |                         |        |  处理器2
+--------+                         +--------+  可运行进程15

处理器1       将某个运行队列中的进程移入        
可运行队列20  到其他的运行队列中，           
              以降低处理器负载的不均衡程度


                 负载平衡程序
```