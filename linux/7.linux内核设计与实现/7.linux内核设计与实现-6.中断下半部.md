# 中断下半部

为啥中断处理程序执行越快越好?
- 1. 中断处理程序以异步方式执行并且它有可能打断其他重要代码（甚至包括其他中断处理程序）的执行。
- 2. 如果当前有一个中断处理程序正在执行，在最好的情况下，与该中断同级的其他中断会被屏蔽，在最坏的情况下，所有其他中断都会被屏蔽。 
- 3. 由于中断处理程序玩玩需要对硬件进行操作，所以它们通常有很高的时限要求
- 4. 中断处理程序不在进程上下文中运行，所以它们不能阻塞

下半部的任务就是执行与中断处理密切相关但中断处理程序本身不执行的工作。
最好是中断处理程序将所有工作都交给下半部执行。

其实没有什么标准说哪些工作交给上半部或者下半部，
借鉴:

- 1. 如果一个任务对时间非常敏感，将其放在中断处理程序中执行，
- 2. 任务未和硬件相关， 将其放在中断处理程序中执行
- 3. 任务要保证不被其他中断(特别是相同类型的中断)打断
- 4. 其他任务，放在下半部执行

### 6.1.1 为什么要用下半部

2.6版本吧中内个体重了三种: 软中断，tasklet 和 工作队列

| 下半部机制 | 状态 |
| --------- | ---- |
| BH | 在2.5中去除 |
| 任务队列 Task queues | 2.5中去除 |
| 软中断 Softirq | 在2.3中引入 |
| Tasklet | 在2.3中引入 |
| 工作队列 Work queues | 在2.5引入 |

## 6.2 软中断

代码位于 kernel/softirq.c
软中断使用的较少。

### 6.2.1 软中断的实现

软中断是在编译期间静态分配的。它不像 tasklets 那样被动态地注册或去除
软中断有softirq_action 结构表示 定义在 linux/interrupt.h中

```C
struct softirq_action {
    void (*action) (struct softirq_action *); // 待执行的函数
    void *data; // 传给函数的参数
}
```

kernel/softirq.c中定义了一个包含有32个该结构体的数组

```static struct softirq_action softirq_vec[32];```

每个被注册的软中断都占据该数组的一项。因此最多可能又32个软中断。
当前版本中，32个只用了6个

1. 软中断处理程序

```C
void softirq_handler(struct softirq_action *)
```

当内个运行一个软中断程序的时候，它就会执行这个action函数，其唯一的参数为指向响应softirq_action结构体的指针。

一个软中断不会抢占另外一个软中断，实际上，唯一可以抢占软中断的是中断处理程序。其他中断——甚至是相同类型的软中断——可以在其他处理器上同时执行

2. 执行软中断

一个注册的软中断必须在被标记后才会执行。这被称为触发软中断 raising the softirq , 中断处理程序会在返回前标记它的软中断，使其稍后被执行。于是，在合适的时刻，该软中断就会运行。

- 在处理完一个硬件中断
- 在ksoftirqd 内核线程中
- 在那些现实检查和执行待处理的软中断的代码中，如网络子系统

软中断唤起后都要在 do_softirq()中执行

```
u32 pending = softirq_pending(cpu);

if (pending) {
    struct softirq_action *h = softirq_vec;
    softirq_pending(cpu) = 0;
    
    do {
        if (pending &1)
            h->action(h);
        h++;
        pending >> = 1;
    } while(pending);
}
```

```
+----------------+
|  do_softirq()  |
+-----------+----+
            |
            |      +------------------------+
            |      | 获取待处理              |
            +------> softirq_pending(cpu)宏  |
                   +----------+-------------+
                              |
                   +----------V-------------+
                   |    u32 pending         |
                   |    保存软中断           |
                   +----------+-------------+
                              |
                   +----------v-------------+
                   | 清理软中断              |
                   | softirq_pending(cpu)=0 |
                   +----------+-------------+
                              |
                  h=0         |  pending 
                  +-----------V-----------------------------+ 
              +>  |1111 1111 1100 0000 0010 0000 00000 0000 |
              |   +-----------------------------------------+
              |               |
              |        /------V----\
              +-----+ /  pending    \ +-------+
            h++       \  第一位为1？ /         |
                       \-----+-----/          |
                             | 是             |
                     +-------v-------+        |
                     |  h->action(h) |        |
                     |  调用         |        |
                     +---------------+        |
                                              |
                             +----------------+
                             |
                             v

```

- 用户局部变量 pending保存 softirq_pending()宏的返回值。它是处理的软中断的32位位图，如果第n位设置为1，那么第n位对应类型的软中断等待处理
- 现在待处理的软中断位图已经被保存，可以将实际的软中断位图清零了
- 将指针h指向softirq__vec的第一项
- 如果pending的第一位被置为1，h->action(h)被调用
- 指针加1，所以现在他指向softirq_vec数组的第二项
- bitmask_pending右移一位。这样会丢弃第一位，然后让其他各位一次向右移动一个位置
- 现在指针指向数组的第二项，pending_mask的第二位现在也到了第一位上
- 直到pending变为0，表明已经没有待处理的软中断了

### 6.2.2 使用软中断

软中断保留给系统中对时间要求最严格以及最重要的下半部使用。

目前只有两个子系统: 网络和SCSI 直接使用软中断，此外 内个定时器和tasklets都是建立在软中断上的

对于时间要求严格并能自己高效地完成加锁工作的应用，应选择软中断

- 1. 分配索引

在编译期间 通过 linux/interrupt.h中定义一个枚举类型来静态地声明软中断，已经有的软中断枚举:

| Tasklet          | 优先级 | 软中断描述 |
| ---------------- | ----- | --------- |
| HI_SOFTIRQ       | 0 | 优先级高的 tasklets |
| TIMER_SOFTIRQ    | 1 | 定时器的下半部 |
| NET_TX_SOFTIRQ   | 2 | 发送网络的数据包 |
| NET_RX_SOFTIRQ   | 3 | 接收网络数据包 |
| SCSI_SOFTIRQ     | 4 | SCSI的下半部 |
| TASKLET_SOFTIRQ  | 5 | tasklets | 

习惯上 HI_SOFTIRQ作为第一项， TASKLET_SOFTIRQ作为最后一项
新加的项可能插在网络相关的那些项之后、TASKLET_SOFTIRQ之前

- 2. 注册你的处理程序

运行时候通过调用 open_softirq()注册软中断处理程序，该函数有三个参数


```C
open_softirq(NET_TX_SOFTIRQ, net_tx_action, NULL); 
```

软中断处理程序执行的时候，允许响应中断，但它自己不能休眠。
如果一个软中断在它执行的同时再次被处罚，那么另外一个处理器可以同时运行其处理程序。
这意味着任何共享数据都需要严格的锁保护

- 3. 触发软中断

通过在枚举类型的列表中添加新项以及调用open_softirq()注册
raise_softirq()函数可以将一个软中断设置为挂起状态，让它在下次调用do_softirq()函数投入运行

网络子系统可能会调用 raise_softirq(NET_TX_SOFTIRQ);
会触发NET_TX_SOFTIRQ软中断。它的处理程序 net_tx_action()就会在内核下一次执行软中断是投入运行。

内核在执行完中断处理程序后马上会调用do_softirq()函数


## 6.3 Tasklets

Tasklets 是利用软中断实现的一种下半部机制。

通常用tasklets。软中断只在那些执行频率很高和连续性要求很过的情况下才需要。
大多数情况下使用tasklets

### 6.3.1 Tasklets实现

- 1. Tasklet 结构体

```C
struct tasklet_struct{
    struct tasklet_struct *next; // 指向链表的下一个结构体
    unsigned long state;        // tasklet 的状态
    atomic_t count;             // 引用计数器
    void (*func) (unsigned long); // tasklet处理函数
    unsigned long data;         // 给tasklet处理函数的参数
}
```

state:
-    0
-    TASKLET_STATE_SCHED 表明tasklet已被调度，准备投入运行
-    TASKLET_STATE_RUN 只有多处理器的系统上才会作为一种优化来使用，单处理器系统任何时候都清楚单个tasklet是不是正在运行

- 2. 调度tasklets

已调度的tasklet 存放在两个两个单处理器数据结构

 - tasklet_vec 普通tasklet
 - tasklet_hi_vec 高优先级

 tasklets由tasklet_schedule()和tasklet_hi_schedule()函数进行调度

```
+-------------------------------+
| state == TASKLET_STATE_SCHED? |
+-----------+-------------------+
            |
            |
+-----------v---------------+
| 保持中断状态，禁止本地中断  |
+-----------+---------------+
            |
            |
+-----------v-----------------------+
|   tasklet加到每个处理器一个        |
|   tasklet_vec或 tasklet_hi_vec链表|
+-----------------------------------+
            |
            |
+-----------v---------------+
|  唤起TASKLET_SOFTIRQ或    |
|  HI_SOFTIRQ软中断         |
+-----------+---------------+
            |
            |
+-----------v---------------+
|  恢复中断到原状态返回      |
+---------------------------+
```

tasklet_action() 和 tasklet_hi_action()是 tasklet 的核心

1. 禁止核心，并未当前处理器检索tasklet_vec或tasklet_hig_vec链表
2. 当前处理器上的该链表设置为NULL，达到清空效果
3. 允许响应中断
4. 循环遍历获得链表上的每个待处理的tasklet
5. 多处理器系统，检查TASKLET_STATE_RUN来判断这个tasklet是否正在其他处理器上运行，在则调到下一个待处理的tasklet去
6. 当前tasklet没有执行，设置状态TASKLET_STATE_RUN，这样别的处理器就不会再去执行它
7. 检查count值是否=0 确保tasklet没有禁止
8. 执行tasklet
9. 执行完毕清除tasklet的state TASKLET_STATE_RUN标志
10. 重复执行下一个tasklet，直到没有剩余等待处理的tasklets

### 6.3.3 ksoftirqd

每个处理器都有一组辅助处理软中断 的 内核线程。当内核中出现大量软中断的时候，这些内核进程就会辅助处理它们

对于软中断，内个会选择在几个特殊时机进行处理

1 中断处理程序返回时处理是最常见

软中断被处罚的频率有是可能很高（进行大流量的网络通信期间）
处理函数有是还会自行重复触发


如果软中断本身出现的频率很高，
加上他们又有将自己重新设置为可执行状态，
那么就会导致用户空间空间进程无法获得足够的处理器时间，
因而处于饥饿状态。