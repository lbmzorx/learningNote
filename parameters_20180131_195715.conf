<meta http-equiv="refresh" content="5" />
auto_increment_increment = 1 	#表示自增长字段从那个数开始
auto_increment_offset = 1 		#表示自增长字段每次递增的量

back_log = 3000					# back_log 是操作系统在监听队列中所能保持的连接数

binlog_checksum = CRC32			#主从复制事件校验
binlog_row_image = full			#默认full

#binlog_format只有在row格式下，上面的参数才会支持
#当binlog_format=statement不起作用
#binlog_format=mixed，根据实际情况而定

#full：在“before”和“after”影像中，记录所有的列值；
#minimal：在“before”和“after”影像中，仅仅记录被更改的以及能够唯一识别数据行的列值；
#noblob：在“before”和“after”影像中，记录所有的列值，但是BLOB 与 TEXT列除外（如未更改）

#mysql复制主要有三种方式：
#	基于SQL语句的复制(statement-based replication, SBR)，
#	基于行的复制(row-based replication, RBR)，
#	混合模式复制(mixed-based replication, MBR)。
#	对应的，binlog的格式也有三种：STATEMENT，ROW，MIXED。

#① STATEMENT模式（SBR）
#每一条会修改数据的sql语句会记录到binlog中。
#	优点是并不需要记录每一条sql语句和每一行的数据变化，减少了binlog日志量，节约IO，提高性能。
#	缺点是在某些情况下会导致master-slave中的数据不一致(如sleep()函数， last_insert_id()，
#	以及user-defined functions(udf)等会出现问题)

#② ROW模式（RBR）
#	不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样了。
#	而且不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。
#	缺点是会产生大量的日志，尤其是alter table的时候会让日志暴涨。

#③ MIXED模式（MBR）
#   以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，
#	对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式。
 
binlog_cache_size = 128KB		#binlog_cache_size是用来存储事务的二进制日志的缓存
								# show global status like 'binlog_cache_%';
								#若Binlog_cache_disk_use大于0，
								#则说明binlog_cache不够用,增大该值
								# 实际 
								# Binlog_cache_disk_use | 40 
								# 建议: 加大

binlog_stmt_cache_size = 32768		#
#	binlog_cache_size只是为事务缓存的大小而设置，
#	binlog_stmt_cache_size管理语句缓存的大小。 发生事务时非事务语句的缓存的大小

character_set_server = utf8		# 服务器安装时指定的默认字符集设定

concurrent_insert = 1 			
#1) concurrent _insert =0 ，无论MyISAM的表数据文件中间是否存在因为删除而留下俄空闲空间，
#   都不允许concurrent insert。
#2）concurrent_insert = 1，是当MyISAM存储引擎表数据文件中间不存在空闲空间的时候，
#   从文件尾部进行Concurrent Insert。
#3）concurrent_insert = 2, 无论 MyISAM存储引擎的表数据文件的中间部分是否存在因为删除而留下的空闲空间，
#   都允许在数据文件尾部进行concurrent insert操作。

connect_timeout = 10 		
#连接超时时间
#mysql客户端在尝试与mysql服务器建立连接时，
#mysql服务器返回错误握手协议前等待客户端数据包的最大时限。默认10秒

default_storage_engine = InnoDB #
default_time_zone = SYSTEM 		#mysql时区，设置为系统时间
default_week_format = 0 		#WEEK(date[,mode])该函数若mode参数被省略，
								#则使用default_week_format系统自变量的值

#INSERT DELAYED仅适用于MyISAM, MEMORY和ARCHIVE表
#当一个客户端使用INSERT DELAYED时，会立刻从服务器处得到一个确定。
#并且行被排入队列，当表没有被其它线程使用时，此行被插入。
#使用INSERT DELAYED的另一个重要的好处是，来自许多客户端的插入被集中在一起，并被编写入一个块。
#这比执行许多独立的插入要快很多。
delayed_insert_limit = 100      #一次排队插入100条数据
delayed_insert_timeout = 300    #超时若无新的insert delayed语句，则handler线程退出
delayed_queue_size = 1000       #客户端的insert delayed会阻塞




delay_key_write = ON  			#延迟更新索引
#使用表创建选项DELAY_KEY_WRITE创建的myisam表，在查询结束后，不会将索引的改变数据写入磁盘，而是在内存的健缓冲区（In-memory key buffer）中缓存索引改变数据。它只会在清理缓存区，或关闭表时，才将索引块转储到磁盘。对于数据经常改变，并且使用频繁的表，这种模式大大提高了表的处理性能, 不过，如果在服务器或系统奔溃，索引将肯定损坏，并需要修复

div_precision_increment = 4 	#除法精度,mysql 做除法的有效位数
eq_range_index_dive_limit = 10 	#MySQL5.6引入了一个新的系统变量，5.7之后默认为200
# eq_range_index_dive_limit有助于减少查询执行计划的index dive成本
# 在较多等值查询（例如多值的IN查询）情景中，预估可能会扫描的记录数，从而选择相对更合适的索引
# 超过设定值时，会将执行计划分支从 1 变成 2
#1、索引代价较高，但结果较为精确；
#2、索引代价较低，但结果可能不够精确； 

explicit_defaults_for_timestamp = false 	#修改时候 时候自动添加edit_time 列类型为timestamp

ft_min_word_len = 4 						# 最小全文索引字长度
# 全文索引，如果是英文默认值是比较合理的，
# 但是中文绝大部分词都是2个字符，这就导致小于4个字的词都不能被索引
# 改为1 比较合理 

ft_query_expansion_limit = 20 		#作用是指定MyISAM引擎表使用with query expansion进行全文搜索的最大匹配数

group_concat_max_len = 1024 		#提供的group_concat函数可以拼接某个字段值成字符串，
									#如果该字符串长度超过1024就会被截断


innodb_adaptive_hash_index = ON 	#自适应哈希索引
#根据InnoDB的官方文档显示，启用自适应哈希索引后，读取和写入速度可以提高2倍

innodb_additional_mem_pool_size = 2097152 # 设置了InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，
# 所以当我们一个MySQL Instance中的数据库对象非常多的时候，
# 是需要适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率的。 
# 默认值是 1MB ，当发现错误日志中已经有相关的警告信息时，就应该适当的增加该参数的大小

innodb_autoinc_lock_mode = 1
# 插入操作时候
# 值0 一直auto_inc锁，在语句结束的时候才释放这把锁，保证插入的都是连续值，影响到了并发的插入。
# 值1 性能居中。
# 值2 没有了auto_inc锁，的性能是最好的，它所得到的auto_incremant值可能不是连续的。

#http://blog.csdn.net/yaoqinglin/article/details/46633803参考解释
innodb_concurrency_tickets = 5000 	#innodb内部的线程数量的控制参数．据说最好的配置是服务器核数的２倍．
#
innodb_thread_concurrency = 0 
#表示没有并发线程数限制，所有请求都会直接请求线程执行
#设置为0时，则innodb_thread_sleep_delay的设置将会被忽略，不起作用。
#如果数据库没出现性能问题时，使用默认值即可。

#>0 则表示有 并发数限制，当一个新的请求发起时，会检查当前并发线程数是否达到了
# innodb_thread_concurrency的限制值，如果有，则需要sleep一段时间，然后再再次请求
innodb_thread_sleep_delay = 10000 # mysql唤醒线程的间隔时间



innodb_ft_max_token_size = 84 	#存储在InnoDB的FULLTEXT索引中的最大词长。
								#设置这样一个限制后可通过忽略过长的关键字等有效降低索引大小从而加速查询。
innodb_ft_min_token_size = 3    # 全文索引单词最小长度，推荐1
innodb_large_prefix = OFF   	#InnoDB单列索引长度不能超过767bytes，实际上联合索引还有一个限制是3072
								#这个参数默认值是OFF。当改为ON时，允许列索引最大达到3072。
innodb_lock_wait_timeout = 50 	#锁等待超时，指的是事务等待获取资源等待的最长时间，
								# 超过这个时间还未分配到资源则会返回应用失败
innodb_max_dirty_pages_pct = 75 #
#脏页数量太多时，InnoDB引擎会强制进行Checkpoint。目的还是为了保证缓冲池中有足够可用的空闲页


#innodb缓存池有2个区域一个是sublist of old blocks存放不经常被访问到的数据，
# 另外一个是sublist of new blocks存放经常被访问到的数据

# innodb_old_blocks_pct参数是控制进入到sublist of old blocks区域的数量，初始化默认是37.
# innodb_old_blocks_time参数是在访问到sublist of old blocks里面数据的时候，
# 控制数据不立即转移到sublist of new blocks区域，
# 而是在多少微秒之后才会真正进入到new区域，这也是防止new区域里面的数据不会立即被踢出。
#   如果在业务中没有做大量的全表扫描，那么你就可以将innodb_old_blocks_pct增大，
# 减小innodb_old_blocks_time的时间，让有用的查询缓存数据尽量缓存在innodb_buffer_pool_size中，
# 减小磁盘io，提高性能
innodb_old_blocks_pct = 37 		#参数是控制进入到sublist of old blocks区域的数量
innodb_old_blocks_time = 1000   #


innodb_online_alter_log_max_size = 134217728  	
#mysql 5.6.6引入的，
# 数据库实例、表、列等数据库对象的定义和操作过程中需要保持delete、update、insert这些数据，
# 所以需要一个日志去保持，这个参数就是限制这个日志的最大大小，
# 当在对数据库实例、表、列等数据库对象的定义和操作过程中 需要的这个日志的大小比这个限制还大的时候就会报错。
# 默认值 128 MB，最大值 2047 MB

innodb_open_files = 3000 		#限制Innodb能打开的表的数据
innodb_print_all_deadlocks = OFF # ON死锁信息打印到错误日志里

#DML操作是指对数据库中表记录的操作，
# 主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），
# 是开发人员日常使用最频繁的操作
# 每次DML操作都会生成Undo页，系统需要定期对这些undo页进行清理，也就是所谓purge操作

innodb_purge_batch_size = 300 	#当开启独立线程清除undo页时，表示一次删除多少个页
# 表示一次完成多少个undolog page；
# 但这个值有一个有趣的副作用是会影响到undolog的释放，
# 因为总是在128轮purge后释放undolog page，在5.5及之后版本，开始支持128个回滚段
innodb_purge_threads = 1 		#控制是否使用独立线程进行purge操作

innodb_read_ahead_threshold = 56 #预读功能
#通过调整触发异步读取请求所需的顺序页访问数，可以控制Innodb执行提前读操作的时间

innodb_read_io_threads = 4 	#读线程个数，默认是4个，如果CPU是2颗8核的，那么可以设为8
innodb_write_io_threads = 4 #写线程个数，根据电脑配置来设置

innodb_rollback_on_timeout = OFF 
# 为ON，整个事务都会回滚,为OFF，事务会回滚到上一个保存点

innodb_stats_method = nulls_equal
#用来判断如何对待索引的 NULL 值记录， 默认值为 nulls_equal, 表示 将 NULL值记录视为相等的记录

innodb_stats_on_metadata = OFF 
#对INFORMATION_SCHEMA中的一些表进行查询操作，以方便索引统计信息，如果读要求高的建议关闭

innodb_stats_sample_pages = 8  #每次收集统计信息时采样的页数

innodb_strict_mode = OFF 	
# 开启InnoDB严格检查模式，开启此功能后
# 当创建表（CREATE TABLE）、更改表（ALTER TABLE）和
# 创建索引（CREATE INDEX）语句时，如果写法有错误，不会有警告信息，而是直接抛出错误

innodb_table_locks = ON 
#LOCK TABLES会在表上持有两个锁，一个是MySQL层持有的锁，另外InnoDB层也需要持有一个锁
# 注意参数innodb_table_locks=1并且autocommit=0时，InnoDB会留意表的死锁





```
interactive_timeout = 7200
```
服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端

服务器关闭交互式连接前等待活动的秒数
key_cache_age_threshold = 300
key_cache_block_size = 1024
key_cache_division_limit = 100
log_queries_not_using_indexes = OFF
long_query_time = 1
loose_max_statement_time = 0
loose_rds_indexstat = OFF
loose_rds_max_tmp_disk_space = 10737418240
loose_rds_tablestat = OFF
loose_rds_threads_running_high_watermark = 50000
loose_tokudb_buffer_pool_ratio = 0
lower_case_table_names = 1
low_priority_updates = 0
max_allowed_packet = 1024M
max_connect_errors = 100
max_length_for_sort_data = 1024
max_prepared_stmt_count = 16382
max_write_lock_count = 102400
myisam_sort_buffer_size = 262144
net_read_timeout = 30
net_retry_count = 10
net_write_timeout = 60
open_files_limit = 65535
performance_schema = OFF
query_alloc_block_size = 8192
query_cache_limit = 1048576
query_cache_size = 3145728
query_cache_type = 0
query_cache_wlock_invalidate = OFF
query_prealloc_size = 8192
rds_reset_all_filter = 0
slow_launch_time = 2
sql_mode = 
table_definition_cache = 512
table_open_cache = 2000
thread_stack = 262144
tmp_table_size = 2097152
transaction_isolation = READ-COMMITTED
wait_timeout = 86400
